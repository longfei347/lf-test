<!doctype html>
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
	<meta charset="utf-8">
	<title>为你封心</title>
	<link rel="shortcut icon" href="../img/dang.ico" type="image/x-icon">
</head>

<body style="background: url(../img/topbg.png) repeat;" ryt12405="1">
	<div style="text-align: center;">
		<canvas id="myCanvas" width="600" height="400" style="border:1px solid #c3c3c3;background-color:black;">Your browser does not support the canvas element.</canvas>
	</div>
	<div style="text-align: center;">为你封心</div>
	<div style="text-align: center;">create by <a href="http://htmlcssjs.duapp.com" target="_blank">dragonfly</a> 
	</div>
	<script>
	function getRandomNumber(n, t) {
		return n + Math.floor(Math.random() * (t - n + 1))
	}
	var i, j, c, cxt, o, q, balls, cyc, k, ball;
	Vector2 = function(n, t) {
		this.x = n || 0, this.y = t || 0
	}, Vector2.prototype = {
		constructor: Vector2,
		set: function(n, t) {
			return this.x = n, this.y = t, this
		},
		copy: function(n) {
			return this.x = n.x, this.y = n.y, this
		},
		clone: function() {
			return new THREE.Vector2(this.x, this.y)
		},
		add: function(n, t) {
			return this.x = n.x + t.x, this.y = n.y + t.y, this
		},
		addSelf: function(n) {
			return this.x += n.x, this.y += n.y, this
		},
		sub: function(n, t) {
			return this.x = n.x - t.x, this.y = n.y - t.y, this
		},
		subSelf: function(n) {
			return this.x -= n.x, this.y -= n.y, this
		},
		multiplyScalar: function(n) {
			return this.x *= n, this.y *= n, this
		},
		divideScalar: function(n) {
			return n ? (this.x /= n, this.y /= n) : this.set(0, 0), this
		},
		negate: function() {
			return this.multiplyScalar(-1)
		},
		dot: function(n) {
			return this.x * n.x + this.y * n.y
		},
		lengthSq: function() {
			return this.x * this.x + this.y * this.y
		},
		length: function() {
			return Math.sqrt(this.lengthSq())
		},
		normalize: function() {
			return this.divideScalar(this.length())
		},
		distanceTo: function(n) {
			return Math.sqrt(this.distanceToSquared(n))
		},
		distanceToSquared: function(n) {
			var t = this.x - n.x,
				i = this.y - n.y;
			return t * t + i * i
		},
		setLength: function(n) {
			return this.normalize().multiplyScalar(n)
		},
		equals: function(n) {
			return n.x === this.x && n.y === this.y
		},
		rotateSelf: function(n, t) {
			var i = new Vector2,
				r;
			i.sub(this, n), t *= Math.PI / 180, r = [
				[Math.cos(t), -Math.sin(t)],
				[Math.sin(t), Math.cos(t)]
			], this.x = n.x + r[0][0] * i.x + r[0][1] * i.y, this.y = n.y + r[1][0] * i.x + r[1][1] * i.y
		},
		reflectionSelf: function(n) {
			var t = n.normalize();
			this.subSelf(t.multiplyScalar(2 * this.dot(t)))
		},
		distanceToLine: function(n, t) {
			if (t.x === n.x) return Math.abs(this.y - n.y);
			if (t.y === n.y) return Math.abs(this.x - n.x);
			var i = (t.y - n.y) / (t.x - n.x),
				r = -1,
				u = n.y - i * n.x;
			return Math.abs(i * this.x + r * this.y + u) / Math.sqrt(i * i + r * r)
		},
		isInLineSegment: function(n, t) {
			var i = new Vector2.sub(n, t).vertical(),
				r = n.distanceTo(t),
				u = this.distanceToLine(n, (new Vector2).add(n, i)),
				f = this.distanceToLine(t, (new Vector2).add(t, i));
			return Math.round(u + f) == Math.round(r) ? !0 : !1
		},
		vertical: function() {
			return new Vector2(-this.y, this.x)
		}
	}, Vector2.sub = function(n, t) {
		return new Vector2(n.x - t.x, n.y - t.y)
	}, Vector2.rotate = function(n, t, i) {
		var r = new Vector2,
			u;
		return r.sub(n, t), i *= Math.PI / 180, u = [
			[Math.cos(i), -Math.sin(i)],
			[Math.sin(i), Math.cos(i)]
		], new Vector2(t.x + u[0][0] * r.x + u[0][1] * r.y, t.y + u[1][0] * r.x + u[1][1] * r.y)
	};
	var heartPath = [160, 296, 159, 292, 155, 281, 145, 267, 129, 250, 108, 231, 85, 211, 62, 190, 45, 167, 34, 143, 33, 119, 42, 97, 58, 79, 80, 68, 103, 65, 125, 71, 142, 84, 153, 99, 159, 112, 160, 120, 161, 119, 162, 111, 168, 98, 180, 83, 197, 71, 219, 65, 242, 68, 264, 79, 280, 98, 288, 120, 286, 144, 276, 168, 258, 191, 235, 212, 212, 232, 191, 251, 176, 268, 166, 282, 161, 292, 161, 296],
		heartPathArr = [],
		lineArr = [];
	for (i = 0, j = heartPath.length; i < j; i += 2) heartPathArr.push([heartPath[i], heartPath[i + 1]]);
	for (c = document.getElementById("myCanvas"), cxt = c.getContext("2d"), cxt.strokeStyle = "red", o = 0, q = heartPathArr.length; o < q - 1; o++) lineArr.push({
		p1: new Vector2(heartPathArr[o][0], heartPathArr[o][1]),
		p2: new Vector2(heartPathArr[o + 1][0], heartPathArr[o + 1][1])
	});
	for (balls = [], cyc = 15, k = 0; k < 2e3; k++) ball = {
		position: new Vector2(160, 200),
		r: getRandomNumber(1, 1),
		v: new Vector2(getRandomNumber(-40, 40), getRandomNumber(-40, 40)),
		render: function() {
			cxt.fillStyle = "white", cxt.beginPath(), cxt.arc(this.position.x, this.position.y, this.r, 0, Math.PI * 2, !0), cxt.closePath(), cxt.fill()
		}
	}, balls.push(ball);
	setInterval(function() {
		var n, i, r, u, t;
		for (cxt.fillStyle = "rgba(0,0,0,0.1)", cxt.fillRect(0, 0, c.width, c.height), cxt.beginPath(), n = 0, i = heartPathArr.length; n < i; n++) t = heartPathArr[n], cxt.lineTo(t[0], t[1]);
		for (cxt.closePath(), cxt.stroke(), n = 0, i = balls.length; n < i; n++) {
			for (balls[n].render(), r = 0, u = lineArr.length; r < u; r++) t = lineArr[r], balls[n].position.distanceToLine(t.p1, t.p2) < balls[n].r && balls[n].position.isInLineSegment(t.p1, t.p2) && (balls[n].position.x -= balls[n].v.x * cyc / 1e3, balls[n].position.y -= balls[n].v.y * cyc / 1e3, balls[n].v.reflectionSelf(Vector2.sub(t.p1, t.p2).vertical()));
			balls[n].position.x += balls[n].v.x * cyc / 1e3, balls[n].position.y += balls[n].v.y * cyc / 1e3
		}
	}, 15)
	</script>
</body>

</html>
