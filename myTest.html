<!DOCTYPE HTML>
<html>

<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<script src="js/jquery-1.11.0.js"></script>
	<!--<script src="js/zepto.js"></script>
	<script src="js/event.js"></script>
	<script src="js/touch.js"></script>
	<script src="js/angular.js"></script> -->
	<title>my test</title>
</head>
<style>

form>.long{
	background-color: #f90;
}
input[type=text]{
	background-color: #ccc;
}
</style>
<body>
	<form method="post" id="s_form">
		<input type="text" class="long" name="long" id="long" onkeydown="console.log(event.keyCode,event.key)">
	</form>
	<p id="time"></p>
</body>
<script>
/*window.onerror = function(message,url,line){
	// 汇报错误
	console.log("文件" + url + "中的第" + line + "行代码出错，错误信息：" + message);
	// 不希望此错误继续扩散
	return true;
};
function isJson(str) {
	if (typeof str == 'string') {
		try {
			var obj = JSON.parse(str);
			return obj
		} catch(error) {
			throw error
			return false;
		}
	}
}
isJson('long')*/


/*// async/await
var sleep = function (time) {
    return new Promise(function (resolve, reject) {
        setTimeout(function () {
            resolve();
        }, time);
    })
};

var start = async function () {
    // 在这里使用起来就像同步代码那样直观
    console.log('start');
    await sleep(3000);
    console.log('end');
};

start();*/

/*var a=[1,3,6];
var b=[...a]; 数组复制*/

/*var v1 = "abc";
var v2 = true;
var v3 = 10;
var v4 = Symbol("foo")
var v5 = 2;

var obj = Object.assign({}, v1, null, v2, undefined, v3, v4);
// 原始类型会被包装，null 和 undefined 会被忽略。
// 注意，只有字符串的包装对象才可能有自身可枚举属性。
console.log(obj); // { "0": "a", "1": "b", "2": "c" }
// console.log(Object.assign({},v2,v3)); //{}*/

/*
//Object.assign深拷贝一个对象,当修改该对象时,会改变原对象, 使用JSON.stringify,JSON.parse
 var l={
	l:{
		l:1,
		f:2
	}
}, f={ll:2},o={};
Object.assign(o,l,f);
o.l.l=12;
*/

/*var ob=[
  {
    "typecode": "0",
    "TYPENAME": "Android",
    "ID": 30,
    "MODLE": "COMPILER_PLATFORM"
  },
  {
    "TYPECODE": "1",
    "TYPENAME": "IOS",
    "ID": 31,
    "MODLE": "COMPILER_PLATFORM"
  }
];
ob.forEach(function(item, index) {
	var i;
	for (i in item) {
		// console.log(i);
		item[i.toUpperCase()] = item[i];
	}
})*/
/*for (;1;) {
	console.log(1)
}
while(true) {
	console.log(1);
}*/
/*var i="10000000000";
for (var j=0;j<Number.MAX_VALUE;j++) {
	i+=i;
	console.log(i)
}*/
/*!function() {
	var a = b = c = 0;
	var D2016 = new Date(2016,5,1)
	setInterval(function(){
		var D = new Date(), val = Math.round((D2016.getTime() - D.getTime())/1000),
			daytimes = val%(86400),//60*60*24
			days = Math.floor(val/86400),
			hours = Math.floor(daytimes/3600)%24,
			minutes = Math.floor(daytimes/60)%60,
			seconds = daytimes%60;
			$("#time").html("还剩"+days+"天, "+hours+"时, "+minutes+"分, "+seconds+"秒")
	}, 1000);
}();*/
/*//if(!Function.prototype.bind) {
Function.prototype.bind = function(oThis) {
	if (typeof this !== 'function') {
		throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
	}
	var fSlice = [].slice,
		aArgs = fSlice.call(arguments, 1),
		fToBind = this,
		fNOP = function() {},
		fBound = function() {
			return fToBind.apply(this instanceof fNOP ? this : oThis || window, aArgs.concat(fSlice.call(arguments)));
		};

	fNOP.prototype = this.prototype;
	fBound.prototype = new fNOP();
	return fBound;
};

function long(argument) {
	this.name = argument||this.name;
	console.log(this.name);
}
long.bind({
	name: "fei"
})();
//}*/

</script>

</html>
