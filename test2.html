<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>Test2</title>
  <script src="js/j.js"></script>
  <!-- <script type="module" src="js/test.js"></script> -->
  <!-- <script src="NetworkBundleActivity.js"></script> -->
  <!-- <script src="js/base.js"></script>
  <script src="js/lodash.js"></script>
  <script src="js/angular.js"></script> -->
  <script src="js/_30s.js"></script>
  <script src="js/base.js"></script>
  <script src="js/axios.js"></script>
  <link rel="stylesheet" href="css/style.css">
</head>
<style>
.bar {
  height: 30px;
  background-color: #cd0000;
  position: fixed; 
  left: 0; right: 0; top: 120px;
  /* Safari下z-index无效 */
  z-index: 99;
}
.box {
    text-align: center;
}
.rotate {
    transform: perspective(300px) rotateY(40deg);
}
</style>
</head>

<body>
<div class="bar"></div>
<div class="box">
    <img class="rotate" src="mm1.jpg">
</div>
  <div class="button">下一步</div>
  <div class="turn">
    旋转10圈
  </div>
  <div class="cicle"></div>
  <div class="linear-gradient"></div>
  <div class="water-wave">
    <div class="water-wave1"></div>
    <div class="water-wave2"></div>
    <div class="water-wave3"></div>
  </div>
  <div class="boundary">
    <div class="ball"></div>
  </div>
  <div class="loading">
    <div></div>
    <div></div>
    <div></div>
    <div></div>
  </div>
  <div class="face-scan"></div>
  <div class="rainbow"></div>
  <div class="earth-rotate">
    <div>
      <p></p>
    </div>
  </div>
  <div class="simple-loading"></div>
  <!-- <div id="demo">E:target伪类使用方法  </div> -->
  <!-- <div id="chrome_detect" title="chrome">haha</div> -->
  <!-- <long>hello,world</long> -->
  <input type="text" onkeydown="document.getElementById('output').innerHTML=event.keyCode">
  <span id="output"></span>
  <img src="images/001.gif" alt="">
  <form action="" class="aaa">
    <!-- <input type="text" id="fei" pattern="\w{3,8}"> -->
    <!-- <item name="item3" class="mark" label="指标类型:" width="50%">
      <dropdown name="metric_type" id="metric_type" valueField="code" textField="name" datafield="formData.metric_type" showClearBtn="false">
        <attr name="rule">{required:true}</attr>
        <attr name="dataset">{"source": {"url" : "services/saasDictItemSearch?class_code=METRIC_TYPE"}}</attr>
      </dropdown>
    </item> -->

    <input type="text" id="inputText" value="测试文本" />
    <button type="button" id="copy" class="btn">复制文本框内容</button>
    <button type="button" onclick="copyToClipboard(this.innerHTML)">复制自身</button>
  </form>
</body>
<script>
$('.button').on('click', ()=>{
  console.log(11)
})
// 遍历所有的输入框
([]).slice.call(document.querySelectorAll('input, textarea')).forEach(function(ele) {
  ele.addEventListener('paste', function(event) {
    // 输入框类型
    var type = this.getAttribute('type') || this.type;
    // 剪切板数据对象
    var clipboardData = event.clipboardData || window.clipboardData;
    // 粘贴内容
    var paste = '';
    // 剪切板对象可以获取
    if (!clipboardData) { return; }
    // 获取选中的文本内容
    var userSelection, textSelected = '';
    if (window.getSelection) {
      // 现代浏览器
      // 直接window.getSelection().toString()对于IE的输入框无效
      textSelected = this.value.slice(ele.selectionStart, ele.selectionEnd);
    } else if (document.selection) {
      // 旧IE浏览器
      textSelected = document.selection.createRange().text;
    }
    // 只有输入框没有数据，或全选状态才处理
    if (this.value.trim() == '' || textSelected === this.value) {
      // 阻止冒泡和默认粘贴行为
      event.preventDefault();
      event.stopPropagation();
      // 获取粘贴数据
      paste = clipboardData.getData('text') || '';
      // 进行如下处理
      // 除非是password，其他都过滤前后空格
      if (type != 'password') {
        paste = paste.trim();
      }
      // 邮箱处理，可能会使用#代替@避免被爬虫抓取
      if (type == 'email') {
        paste = paste.replace('#', '@');
      } else if (type == 'tel') {
        // 手机号处理
        paste = paste.replace(/^\+86/, '');
        // 如果此时剩余所有数字正好11位
        if (paste.match(/\d/) && paste.match(/\d/g).length == 11) {
          paste = paste.replace(/\D/g, '');
        }
      } // 其他类型处理大家自行补充...

      // 插入
      this.value = paste;
    }
  });
});

function aa(str) {
  var i = 0,
    len = str.length;
  for (; i < str.length; i++) {
    if (str.charAt(i) == 'A') {
      str = str.substring(0, i) + 'ABB' + str.substring(i);
      i += 2;
    } else {
      str = str.substring(0, i) + 'A' + str.substring(i);
    }
  }
  console.log(str);
  return str
}
/*var instance = axios.create({
  baseURL: 'http://rapapi.org/mockjs/31038',
  timeout: 1000,
  // headers: {'X-Custom-Header': 'foobar'}
});
instance.get('/long/first').then(res=>console.log(res.data))*/
/*function* foo(x) {
  var y = 2 * (yield x + 1);
  var z = yield y / 3;
  return (x + y + z);
}

var a = foo(5);
console.log(a.next()) // Object{value:6, done:false}
console.log(a.next()) // Object{value:NaN, done:false}
console.log(a.next()) // Object{value:NaN, done:true}

var b = foo(5);
console.log(b.next()) // { value:6, done:false }
console.log(b.next(12)) // { value:8, done:false }
console.log(b.next(13)) // { value:42, done:true }*/

const isValidJSON = obj => {
  try {
    JSON.parse(obj);
    return true;
  } catch (e) {
    return false;
  }
};
const isArrayLike = val => {
  try {
    return [...val], true;
  } catch (e) {
    return false;
  }
};
const isPlainObject = val => !!val && typeof val === 'object' && val.constructor === Object;
const getURLParameters = url =>
  (url.match(/([^?=&]+)(=([^&]*))/g) || []).reduce(
    (a, v) => ((a[v.slice(0, v.indexOf('='))] = v.slice(v.indexOf('=') + 1)), a), {}
  );

const hexToRGB = hex => {
  let alpha = false,
    h = hex.slice(hex.startsWith('#') ? 1 : 0);
  if (h.length === 3) h = [...h].map(x => x + x).join('');
  else if (h.length === 8) alpha = true;
  h = parseInt(h, 16);
  return (
    'rgb' +
    (alpha ? 'a' : '') +
    '(' +
    (h >>> (alpha ? 24 : 16)) +
    ', ' +
    ((h & (alpha ? 0x00ff0000 : 0x00ff00)) >>> (alpha ? 16 : 8)) +
    ', ' +
    ((h & (alpha ? 0x0000ff00 : 0x0000ff)) >>> (alpha ? 8 : 0)) +
    (alpha ? `, ${h & 0x000000ff}` : '') +
    ')'
  );
};

const httpGet = (url, callback, err = console.error) => {
  const request = new XMLHttpRequest();
  request.open('GET', url, true);
  request.onload = () => callback(request.responseText);
  request.onerror = () => err(request);
  request.send();
};

const httpPost = (url, data, callback, err = console.error) => {
  const request = new XMLHttpRequest();
  request.open('POST', url, true);
  request.setRequestHeader('Content-type', 'application/json; charset=utf-8');
  request.onload = () => callback(request.responseText);
  request.onerror = () => err(request);
  request.send(data);
};

const isBrowser = () => ![typeof window, typeof document].includes('undefined');

let cookieStr = 'long=1;fei=2'
const parseCookie = str =>
  str.split(';').map(v => v.split('=')).reduce((acc, v) => {
    acc[decodeURIComponent(v[0].trim())] = decodeURIComponent(v[1].trim());
    return acc;
  }, {});
// parseCookie(cookieStr)
const prettyBytes = (num, precision = 3, addSpace = true) => {
  const UNITS = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
  if (Math.abs(num) < 1) return num + (addSpace ? ' ' : '') + UNITS[0];
  const exponent = Math.min(Math.floor(Math.log10(num < 0 ? -num : num) / 3), UNITS.length - 1);
  const n = Number(((num < 0 ? -num : num) / 1000 ** exponent).toPrecision(precision));
  return (num < 0 ? '-' : '') + n + (addSpace ? ' ' : '') + UNITS[exponent];
};
// console.log(prettyBytes(1000))
const RGBToHex = (r, g, b) => ((r << 16) + (g << 8) + b).toString(16).padStart(6, '0');
// console.log(RGBToHex(255, 165, 1)); // 'ffa501'
const toCurrency = (n, curr, LanguageFormat = undefined) =>
  Intl.NumberFormat(LanguageFormat, { style: 'currency', currency: curr }).format(n);
// console.log(toCurrency(123456.789, 'USD', 'en-us')); // $123,456.79  | currency: US Dollar | currencyLangFormat: English (United States)
// console.log(toCurrency(123456.789, 'USD', 'fa')); // ۱۲۳٬۴۵۶٫۷۹ ؜$ | currency: US Dollar | currencyLangFormat: Farsi
const toOrdinalSuffix = num => {
  const int = parseInt(num),
    digits = [int % 10, int % 100],
    ordinals = ['st', 'nd', 'rd', 'th'],
    oPattern = [1, 2, 3, 4],
    tPattern = [11, 12, 13, 14, 15, 16, 17, 18, 19];
  return oPattern.includes(digits[0]) && !tPattern.includes(digits[1]) ?
    int + ordinals[digits[0] - 1] :
    int + ordinals[3];
};
const objectFromPairs = arr => arr.reduce((a, v) => (a[v[0]] = v[1], a), {});
objectFromPairs([
  ['a', 1],
  ['b', 2]
]) // -> {a: 1, b: 2}
const speak = message => {
  const msg = new SpeechSynthesisUtterance(message);
  msg.voice = window.speechSynthesis.getVoices()[0];
  window.speechSynthesis.speak(msg);
};
// speak('Hello, World');// -> plays the message
// 复制到剪贴板
const copyToClipboard = str => {
  const el = document.createElement('textarea');
  el.value = str;
  el.setAttribute('readonly', '');
  el.style.position = 'absolute';
  el.style.left = '-9999px';
  document.body.appendChild(el);
  const selected =
    document.getSelection().rangeCount > 0 ? document.getSelection().getRangeAt(0) : false;
  el.select();
  document.execCommand('copy');
  document.body.removeChild(el);
  if (selected) {
    document.getSelection().removeAllRanges();
    document.getSelection().addRange(selected);
  }
};

// const compose = (...fns) => fns.reduce((f, g) => (...args) => f(g(...args)));
const compose = function(...fns) {
  return fns.reduce(function(f, g) {
    // console.log(f, g)
    return function(...args) {
      return f(g(...args))
    }
  })
}
const add5 = x => x + 5;
const multiply = (x, y) => x * y;
const multiplyAndAdd5 = compose(add5, multiply);
console.log(multiplyAndAdd5(5, 2))
/*Observe(home)
// 创建一个Observe构造函数
// 写数据劫持的主要逻辑
function Observe(data) {
  // 所谓数据劫持就是给对象增加get,set
  // 先遍历一遍对象再说
  for (let key in data) { // 把data属性通过defineProperty的方式定义属性
    let val = data[key];
    observe(val); // 递归继续向下找，实现深度的数据劫持
    Object.defineProperty(data, key, {
      configurable: true,
      get() {
        return val;
      },
      set(newVal) { // 更改值的时候
        if (val === newVal) { // 设置的值和以前值一样就不理它
          return;
        }
        val = newVal; // 如果以后再获取值(get)的时候，将刚才设置的值再返回去
        observe(newVal); // 当设置为新值后，也需要把新值再去定义成属性
      }
    });
  }
}

// 外面再写一个函数
// 不用每次调用都写个new
// 也方便递归调用
function observe(data) {
  // 如果不是对象的话就直接return掉
  // 防止递归溢出
  if (!data || typeof data !== 'object') return;
  return new Observe(data);
}*/

/*const initArr = (end, start = 0) =>
  Array.apply(null, Array(end - start)).map((v, i) => i + start);*/
/*function Fibonacci2 (n , ac1 = 1 , ac2 = 1) {
  if( n <= 1 ) {return ac2};
  console.count();
  console.log(ac2, ac1 + ac2)
  return Fibonacci2 (n - 1, ac2, ac1 + ac2);
}

Fibonacci2(100) // 573147844013817200000
// Fibonacci2(1000) // 7.0330367711422765e+208*/
/*var obj = new Proxy({}, {
  get: function (target, key, receiver) {
    console.log(`getting ${key}!`, target,receiver);
    return Reflect.get(target, key, receiver);
  },
  set: function (target, key, value, receiver) {
    console.log(`setting ${key}: ${value}!`, target,receiver);
    return Reflect.set(target, key, value, receiver);
  }
});
obj.count = 1
//  setting count!
++obj.count
//  getting count!
//  setting count!
//  2*/

/*
// typescript 继承方法
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}, a={a:1,b:2}, aa={c:3,d:4};
__extends(a,aa);*/

// console.log('%clong',"color:#f90")


/*let cc = {a: string, b?: number}
function f({a, b}: cc): void {}
function f({a = "", b} = {b: 0}) {
  console.log(arguments.length,a,b)
}
f({a:22,b:33}); // ok, default to {a: "", b: 0}

// 令人困惑的是，这里的冒号不是指示类型的。 如果你想指定它的类型， 仍然需要 在其后写上完整的模式。
let {a, b}: {a: string, b: number} = o;*/

$(function() {
  // document.activeElement;document.styleSheets[0].addRule("body .postTitle", "background-color:red;font-size:16px;")
  document.querySelector("#copy").addEventListener('click', function() {
    var inputText = document.getElementById('inputText');
    var currentFocus = document.activeElement;
    inputText.focus();
    inputText.setSelectionRange(0, inputText.value.length);
    document.execCommand('copy', true);
    currentFocus.focus();
  });
})

/* 
// 不支持
@nonenumerable
class Person {
  get kidCount() {
    return 42;
  }
}
function nonenumerable(target, name, descriptor) {
  descriptor.enumerable = false;
  return descriptor;
}*/

/*var p1 = new Promise((resolve, reject) => {
  setTimeout(resolve, 1000, "one");
});
var p2 = new Promise((resolve, reject) => {
  setTimeout(resolve, 2000, "two");
});
var p3 = new Promise((resolve, reject) => {
  setTimeout(resolve, 3000, "three");
});
var p4 = new Promise((resolve, reject) => {
  setTimeout(resolve, 4000, "four");
});
var p5 = new Promise((resolve, reject) => {
  resolve("resolve");
  // reject("reject");
});

Promise.all([p1, p2, p3, p4, p5]).then(values => {
  console.log(values);
}, reason => {
  console.log(reason)
});
*/
/*var p1 = Promise.resolve(3);
p1.then(value=>console.log(value))
var p2 = 1337;
var p3 = new Promise((resolve, reject) => {
  // console.log(resolve.toString())
  resolve(1,22,3,54,55)
  // setTimeout(resolve, 100, "foo");
});

Promise.all([p1, p2, p3]).then(values => {
  console.log(values); // [3, 1337, 1]
});*/

// throw new Error("hello world 2  " ) //不往下执行
/*// 简单实例继承
var O = {
  name: "long",
  sex: "nan"
}

function Animal(obj) {
  this.name = obj.name;
  this.sex = obj.sex;
  return this;
}
var myo = Animal.call(O, O);*/

/*var a = 1,
    b = function a(x) {
      console.count()
        x && a(--x);
    };
console.log(a) // 1 */

var arr = [2, 88, 6, 8, 3, 0, 34, 72];
var sort = {};
sort.insertiSort = function(arr) {
  for (var i = 0; i < arr.length - 1; i++) {
    var insert = arr[i + 1]; //要被插入的元素
    var index = i + 1; //要被插入的元素的下标
    for (var j = i; j >= 0; j--) {
      // 谁小就插入到谁的前面,从小到大
      if (insert < arr[j]) {
        arr[j + 1] = arr[j];
        index = j;
      } else {
        continue;
      }
      console.count("执行次数");
    }
    arr[index] = insert;
    console.log(arr + "\n");
  }
}
sort.insertiSort(arr);

// $('.feif').offsetParent().css('background-color', 'red');

/*var stag =
`<!-- <aa name="dlfk">-->
    <!-- <bfd><f name="fdf"></f></bfd>  -->
<!-- </aa>  -->
<!--<a>
  <b></b
</a>-->`;
var ntag = stag.replace(/(?:<!--\s*<)([\s\S]+?)(?:>\s*-->)+/g, function(sAll,group) {
  // console.count();
  // console.log(i);
  var str = group.match(/[\w-]+/)[0];
  if (group.indexOf("<") > 0) {
    return "<code_" +  group.slice(0, -str.length) + "code_" + str +">";
  } else {
    return "<code_" +  group + ">";
  }
})
// console.log(ntag)*/

/*var ntag = stag.replace(/<!--<\/?([\w-])+/g, function(v,i) {
  return v.substr(4).replace(/([\w-]+)$/, "code_$1");
}).replace(/<\/([\w-]+)>-->/g, "</code_$1>").replace(">-->",">");*/

/*var myFrame = document.createElement('iframe');
document.body.appendChild(myFrame);
var myArray = window.frames[window.frames.length-1].Array;
var arr = new myArray(1,2,10); // [a,b,10]
// myArray 的构造器已经丢失，instanceof 的结果将不正常
// 构造器是不能跨 frame 共享的
console.log(arr instanceof Array)// false*/

/*function getCategory(age) {
  var category = "";
  switch (true) {
    case isNaN(age):
      category = "not an age";
      break;
    case (age >= 50):
      category = "Old";
      break;
    case (age <= 20):
      category = "Baby";
      break;
    default:
      category = "Young";
      break;
  };
  return category;
}
console.log(getCategory(5)); // 将返回 "Baby"*/
</script>

</html>
